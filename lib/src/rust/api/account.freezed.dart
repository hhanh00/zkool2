// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'account.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$Account {
  int get coin => throw _privateConstructorUsedError;
  int get id => throw _privateConstructorUsedError;
  String get name => throw _privateConstructorUsedError;
  String? get seed => throw _privateConstructorUsedError;
  int get aindex => throw _privateConstructorUsedError;
  Uint8List? get icon => throw _privateConstructorUsedError;
  int get birth => throw _privateConstructorUsedError;
  int get position => throw _privateConstructorUsedError;
  bool get hidden => throw _privateConstructorUsedError;
  bool get saved => throw _privateConstructorUsedError;
  bool get enabled => throw _privateConstructorUsedError;
  bool get internal => throw _privateConstructorUsedError;
  int get height => throw _privateConstructorUsedError;
  BigInt get balance => throw _privateConstructorUsedError;

  /// Create a copy of Account
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $AccountCopyWith<Account> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AccountCopyWith<$Res> {
  factory $AccountCopyWith(Account value, $Res Function(Account) then) =
      _$AccountCopyWithImpl<$Res, Account>;
  @useResult
  $Res call(
      {int coin,
      int id,
      String name,
      String? seed,
      int aindex,
      Uint8List? icon,
      int birth,
      int position,
      bool hidden,
      bool saved,
      bool enabled,
      bool internal,
      int height,
      BigInt balance});
}

/// @nodoc
class _$AccountCopyWithImpl<$Res, $Val extends Account>
    implements $AccountCopyWith<$Res> {
  _$AccountCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of Account
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? coin = null,
    Object? id = null,
    Object? name = null,
    Object? seed = freezed,
    Object? aindex = null,
    Object? icon = freezed,
    Object? birth = null,
    Object? position = null,
    Object? hidden = null,
    Object? saved = null,
    Object? enabled = null,
    Object? internal = null,
    Object? height = null,
    Object? balance = null,
  }) {
    return _then(_value.copyWith(
      coin: null == coin
          ? _value.coin
          : coin // ignore: cast_nullable_to_non_nullable
              as int,
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as int,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      seed: freezed == seed
          ? _value.seed
          : seed // ignore: cast_nullable_to_non_nullable
              as String?,
      aindex: null == aindex
          ? _value.aindex
          : aindex // ignore: cast_nullable_to_non_nullable
              as int,
      icon: freezed == icon
          ? _value.icon
          : icon // ignore: cast_nullable_to_non_nullable
              as Uint8List?,
      birth: null == birth
          ? _value.birth
          : birth // ignore: cast_nullable_to_non_nullable
              as int,
      position: null == position
          ? _value.position
          : position // ignore: cast_nullable_to_non_nullable
              as int,
      hidden: null == hidden
          ? _value.hidden
          : hidden // ignore: cast_nullable_to_non_nullable
              as bool,
      saved: null == saved
          ? _value.saved
          : saved // ignore: cast_nullable_to_non_nullable
              as bool,
      enabled: null == enabled
          ? _value.enabled
          : enabled // ignore: cast_nullable_to_non_nullable
              as bool,
      internal: null == internal
          ? _value.internal
          : internal // ignore: cast_nullable_to_non_nullable
              as bool,
      height: null == height
          ? _value.height
          : height // ignore: cast_nullable_to_non_nullable
              as int,
      balance: null == balance
          ? _value.balance
          : balance // ignore: cast_nullable_to_non_nullable
              as BigInt,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$AccountImplCopyWith<$Res> implements $AccountCopyWith<$Res> {
  factory _$$AccountImplCopyWith(
          _$AccountImpl value, $Res Function(_$AccountImpl) then) =
      __$$AccountImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {int coin,
      int id,
      String name,
      String? seed,
      int aindex,
      Uint8List? icon,
      int birth,
      int position,
      bool hidden,
      bool saved,
      bool enabled,
      bool internal,
      int height,
      BigInt balance});
}

/// @nodoc
class __$$AccountImplCopyWithImpl<$Res>
    extends _$AccountCopyWithImpl<$Res, _$AccountImpl>
    implements _$$AccountImplCopyWith<$Res> {
  __$$AccountImplCopyWithImpl(
      _$AccountImpl _value, $Res Function(_$AccountImpl) _then)
      : super(_value, _then);

  /// Create a copy of Account
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? coin = null,
    Object? id = null,
    Object? name = null,
    Object? seed = freezed,
    Object? aindex = null,
    Object? icon = freezed,
    Object? birth = null,
    Object? position = null,
    Object? hidden = null,
    Object? saved = null,
    Object? enabled = null,
    Object? internal = null,
    Object? height = null,
    Object? balance = null,
  }) {
    return _then(_$AccountImpl(
      coin: null == coin
          ? _value.coin
          : coin // ignore: cast_nullable_to_non_nullable
              as int,
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as int,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      seed: freezed == seed
          ? _value.seed
          : seed // ignore: cast_nullable_to_non_nullable
              as String?,
      aindex: null == aindex
          ? _value.aindex
          : aindex // ignore: cast_nullable_to_non_nullable
              as int,
      icon: freezed == icon
          ? _value.icon
          : icon // ignore: cast_nullable_to_non_nullable
              as Uint8List?,
      birth: null == birth
          ? _value.birth
          : birth // ignore: cast_nullable_to_non_nullable
              as int,
      position: null == position
          ? _value.position
          : position // ignore: cast_nullable_to_non_nullable
              as int,
      hidden: null == hidden
          ? _value.hidden
          : hidden // ignore: cast_nullable_to_non_nullable
              as bool,
      saved: null == saved
          ? _value.saved
          : saved // ignore: cast_nullable_to_non_nullable
              as bool,
      enabled: null == enabled
          ? _value.enabled
          : enabled // ignore: cast_nullable_to_non_nullable
              as bool,
      internal: null == internal
          ? _value.internal
          : internal // ignore: cast_nullable_to_non_nullable
              as bool,
      height: null == height
          ? _value.height
          : height // ignore: cast_nullable_to_non_nullable
              as int,
      balance: null == balance
          ? _value.balance
          : balance // ignore: cast_nullable_to_non_nullable
              as BigInt,
    ));
  }
}

/// @nodoc

class _$AccountImpl implements _Account {
  const _$AccountImpl(
      {required this.coin,
      required this.id,
      required this.name,
      this.seed,
      required this.aindex,
      this.icon,
      required this.birth,
      required this.position,
      required this.hidden,
      required this.saved,
      required this.enabled,
      required this.internal,
      required this.height,
      required this.balance});

  @override
  final int coin;
  @override
  final int id;
  @override
  final String name;
  @override
  final String? seed;
  @override
  final int aindex;
  @override
  final Uint8List? icon;
  @override
  final int birth;
  @override
  final int position;
  @override
  final bool hidden;
  @override
  final bool saved;
  @override
  final bool enabled;
  @override
  final bool internal;
  @override
  final int height;
  @override
  final BigInt balance;

  @override
  String toString() {
    return 'Account(coin: $coin, id: $id, name: $name, seed: $seed, aindex: $aindex, icon: $icon, birth: $birth, position: $position, hidden: $hidden, saved: $saved, enabled: $enabled, internal: $internal, height: $height, balance: $balance)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AccountImpl &&
            (identical(other.coin, coin) || other.coin == coin) &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.seed, seed) || other.seed == seed) &&
            (identical(other.aindex, aindex) || other.aindex == aindex) &&
            const DeepCollectionEquality().equals(other.icon, icon) &&
            (identical(other.birth, birth) || other.birth == birth) &&
            (identical(other.position, position) ||
                other.position == position) &&
            (identical(other.hidden, hidden) || other.hidden == hidden) &&
            (identical(other.saved, saved) || other.saved == saved) &&
            (identical(other.enabled, enabled) || other.enabled == enabled) &&
            (identical(other.internal, internal) ||
                other.internal == internal) &&
            (identical(other.height, height) || other.height == height) &&
            (identical(other.balance, balance) || other.balance == balance));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      coin,
      id,
      name,
      seed,
      aindex,
      const DeepCollectionEquality().hash(icon),
      birth,
      position,
      hidden,
      saved,
      enabled,
      internal,
      height,
      balance);

  /// Create a copy of Account
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$AccountImplCopyWith<_$AccountImpl> get copyWith =>
      __$$AccountImplCopyWithImpl<_$AccountImpl>(this, _$identity);
}

abstract class _Account implements Account {
  const factory _Account(
      {required final int coin,
      required final int id,
      required final String name,
      final String? seed,
      required final int aindex,
      final Uint8List? icon,
      required final int birth,
      required final int position,
      required final bool hidden,
      required final bool saved,
      required final bool enabled,
      required final bool internal,
      required final int height,
      required final BigInt balance}) = _$AccountImpl;

  @override
  int get coin;
  @override
  int get id;
  @override
  String get name;
  @override
  String? get seed;
  @override
  int get aindex;
  @override
  Uint8List? get icon;
  @override
  int get birth;
  @override
  int get position;
  @override
  bool get hidden;
  @override
  bool get saved;
  @override
  bool get enabled;
  @override
  bool get internal;
  @override
  int get height;
  @override
  BigInt get balance;

  /// Create a copy of Account
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$AccountImplCopyWith<_$AccountImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$AccountUpdate {
  int get coin => throw _privateConstructorUsedError;
  int get id => throw _privateConstructorUsedError;
  String? get name => throw _privateConstructorUsedError;
  Uint8List? get icon => throw _privateConstructorUsedError;
  int? get birth => throw _privateConstructorUsedError;
  String get folder => throw _privateConstructorUsedError;
  bool? get hidden => throw _privateConstructorUsedError;
  bool? get enabled => throw _privateConstructorUsedError;

  /// Create a copy of AccountUpdate
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $AccountUpdateCopyWith<AccountUpdate> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AccountUpdateCopyWith<$Res> {
  factory $AccountUpdateCopyWith(
          AccountUpdate value, $Res Function(AccountUpdate) then) =
      _$AccountUpdateCopyWithImpl<$Res, AccountUpdate>;
  @useResult
  $Res call(
      {int coin,
      int id,
      String? name,
      Uint8List? icon,
      int? birth,
      String folder,
      bool? hidden,
      bool? enabled});
}

/// @nodoc
class _$AccountUpdateCopyWithImpl<$Res, $Val extends AccountUpdate>
    implements $AccountUpdateCopyWith<$Res> {
  _$AccountUpdateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of AccountUpdate
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? coin = null,
    Object? id = null,
    Object? name = freezed,
    Object? icon = freezed,
    Object? birth = freezed,
    Object? folder = null,
    Object? hidden = freezed,
    Object? enabled = freezed,
  }) {
    return _then(_value.copyWith(
      coin: null == coin
          ? _value.coin
          : coin // ignore: cast_nullable_to_non_nullable
              as int,
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as int,
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      icon: freezed == icon
          ? _value.icon
          : icon // ignore: cast_nullable_to_non_nullable
              as Uint8List?,
      birth: freezed == birth
          ? _value.birth
          : birth // ignore: cast_nullable_to_non_nullable
              as int?,
      folder: null == folder
          ? _value.folder
          : folder // ignore: cast_nullable_to_non_nullable
              as String,
      hidden: freezed == hidden
          ? _value.hidden
          : hidden // ignore: cast_nullable_to_non_nullable
              as bool?,
      enabled: freezed == enabled
          ? _value.enabled
          : enabled // ignore: cast_nullable_to_non_nullable
              as bool?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$AccountUpdateImplCopyWith<$Res>
    implements $AccountUpdateCopyWith<$Res> {
  factory _$$AccountUpdateImplCopyWith(
          _$AccountUpdateImpl value, $Res Function(_$AccountUpdateImpl) then) =
      __$$AccountUpdateImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {int coin,
      int id,
      String? name,
      Uint8List? icon,
      int? birth,
      String folder,
      bool? hidden,
      bool? enabled});
}

/// @nodoc
class __$$AccountUpdateImplCopyWithImpl<$Res>
    extends _$AccountUpdateCopyWithImpl<$Res, _$AccountUpdateImpl>
    implements _$$AccountUpdateImplCopyWith<$Res> {
  __$$AccountUpdateImplCopyWithImpl(
      _$AccountUpdateImpl _value, $Res Function(_$AccountUpdateImpl) _then)
      : super(_value, _then);

  /// Create a copy of AccountUpdate
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? coin = null,
    Object? id = null,
    Object? name = freezed,
    Object? icon = freezed,
    Object? birth = freezed,
    Object? folder = null,
    Object? hidden = freezed,
    Object? enabled = freezed,
  }) {
    return _then(_$AccountUpdateImpl(
      coin: null == coin
          ? _value.coin
          : coin // ignore: cast_nullable_to_non_nullable
              as int,
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as int,
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      icon: freezed == icon
          ? _value.icon
          : icon // ignore: cast_nullable_to_non_nullable
              as Uint8List?,
      birth: freezed == birth
          ? _value.birth
          : birth // ignore: cast_nullable_to_non_nullable
              as int?,
      folder: null == folder
          ? _value.folder
          : folder // ignore: cast_nullable_to_non_nullable
              as String,
      hidden: freezed == hidden
          ? _value.hidden
          : hidden // ignore: cast_nullable_to_non_nullable
              as bool?,
      enabled: freezed == enabled
          ? _value.enabled
          : enabled // ignore: cast_nullable_to_non_nullable
              as bool?,
    ));
  }
}

/// @nodoc

class _$AccountUpdateImpl implements _AccountUpdate {
  const _$AccountUpdateImpl(
      {required this.coin,
      required this.id,
      this.name,
      this.icon,
      this.birth,
      required this.folder,
      this.hidden,
      this.enabled});

  @override
  final int coin;
  @override
  final int id;
  @override
  final String? name;
  @override
  final Uint8List? icon;
  @override
  final int? birth;
  @override
  final String folder;
  @override
  final bool? hidden;
  @override
  final bool? enabled;

  @override
  String toString() {
    return 'AccountUpdate(coin: $coin, id: $id, name: $name, icon: $icon, birth: $birth, folder: $folder, hidden: $hidden, enabled: $enabled)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AccountUpdateImpl &&
            (identical(other.coin, coin) || other.coin == coin) &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.name, name) || other.name == name) &&
            const DeepCollectionEquality().equals(other.icon, icon) &&
            (identical(other.birth, birth) || other.birth == birth) &&
            (identical(other.folder, folder) || other.folder == folder) &&
            (identical(other.hidden, hidden) || other.hidden == hidden) &&
            (identical(other.enabled, enabled) || other.enabled == enabled));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      coin,
      id,
      name,
      const DeepCollectionEquality().hash(icon),
      birth,
      folder,
      hidden,
      enabled);

  /// Create a copy of AccountUpdate
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$AccountUpdateImplCopyWith<_$AccountUpdateImpl> get copyWith =>
      __$$AccountUpdateImplCopyWithImpl<_$AccountUpdateImpl>(this, _$identity);
}

abstract class _AccountUpdate implements AccountUpdate {
  const factory _AccountUpdate(
      {required final int coin,
      required final int id,
      final String? name,
      final Uint8List? icon,
      final int? birth,
      required final String folder,
      final bool? hidden,
      final bool? enabled}) = _$AccountUpdateImpl;

  @override
  int get coin;
  @override
  int get id;
  @override
  String? get name;
  @override
  Uint8List? get icon;
  @override
  int? get birth;
  @override
  String get folder;
  @override
  bool? get hidden;
  @override
  bool? get enabled;

  /// Create a copy of AccountUpdate
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$AccountUpdateImplCopyWith<_$AccountUpdateImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$Folder {
  int get id => throw _privateConstructorUsedError;
  String get name => throw _privateConstructorUsedError;

  /// Create a copy of Folder
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $FolderCopyWith<Folder> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $FolderCopyWith<$Res> {
  factory $FolderCopyWith(Folder value, $Res Function(Folder) then) =
      _$FolderCopyWithImpl<$Res, Folder>;
  @useResult
  $Res call({int id, String name});
}

/// @nodoc
class _$FolderCopyWithImpl<$Res, $Val extends Folder>
    implements $FolderCopyWith<$Res> {
  _$FolderCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of Folder
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? name = null,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as int,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$FolderImplCopyWith<$Res> implements $FolderCopyWith<$Res> {
  factory _$$FolderImplCopyWith(
          _$FolderImpl value, $Res Function(_$FolderImpl) then) =
      __$$FolderImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({int id, String name});
}

/// @nodoc
class __$$FolderImplCopyWithImpl<$Res>
    extends _$FolderCopyWithImpl<$Res, _$FolderImpl>
    implements _$$FolderImplCopyWith<$Res> {
  __$$FolderImplCopyWithImpl(
      _$FolderImpl _value, $Res Function(_$FolderImpl) _then)
      : super(_value, _then);

  /// Create a copy of Folder
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? name = null,
  }) {
    return _then(_$FolderImpl(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as int,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$FolderImpl implements _Folder {
  const _$FolderImpl({required this.id, required this.name});

  @override
  final int id;
  @override
  final String name;

  @override
  String toString() {
    return 'Folder(id: $id, name: $name)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$FolderImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.name, name) || other.name == name));
  }

  @override
  int get hashCode => Object.hash(runtimeType, id, name);

  /// Create a copy of Folder
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$FolderImplCopyWith<_$FolderImpl> get copyWith =>
      __$$FolderImplCopyWithImpl<_$FolderImpl>(this, _$identity);
}

abstract class _Folder implements Folder {
  const factory _Folder({required final int id, required final String name}) =
      _$FolderImpl;

  @override
  int get id;
  @override
  String get name;

  /// Create a copy of Folder
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$FolderImplCopyWith<_$FolderImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$FrostParams {
  int get id => throw _privateConstructorUsedError;
  int get n => throw _privateConstructorUsedError;
  int get t => throw _privateConstructorUsedError;

  /// Create a copy of FrostParams
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $FrostParamsCopyWith<FrostParams> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $FrostParamsCopyWith<$Res> {
  factory $FrostParamsCopyWith(
          FrostParams value, $Res Function(FrostParams) then) =
      _$FrostParamsCopyWithImpl<$Res, FrostParams>;
  @useResult
  $Res call({int id, int n, int t});
}

/// @nodoc
class _$FrostParamsCopyWithImpl<$Res, $Val extends FrostParams>
    implements $FrostParamsCopyWith<$Res> {
  _$FrostParamsCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of FrostParams
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? n = null,
    Object? t = null,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as int,
      n: null == n
          ? _value.n
          : n // ignore: cast_nullable_to_non_nullable
              as int,
      t: null == t
          ? _value.t
          : t // ignore: cast_nullable_to_non_nullable
              as int,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$FrostParamsImplCopyWith<$Res>
    implements $FrostParamsCopyWith<$Res> {
  factory _$$FrostParamsImplCopyWith(
          _$FrostParamsImpl value, $Res Function(_$FrostParamsImpl) then) =
      __$$FrostParamsImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({int id, int n, int t});
}

/// @nodoc
class __$$FrostParamsImplCopyWithImpl<$Res>
    extends _$FrostParamsCopyWithImpl<$Res, _$FrostParamsImpl>
    implements _$$FrostParamsImplCopyWith<$Res> {
  __$$FrostParamsImplCopyWithImpl(
      _$FrostParamsImpl _value, $Res Function(_$FrostParamsImpl) _then)
      : super(_value, _then);

  /// Create a copy of FrostParams
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? n = null,
    Object? t = null,
  }) {
    return _then(_$FrostParamsImpl(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as int,
      n: null == n
          ? _value.n
          : n // ignore: cast_nullable_to_non_nullable
              as int,
      t: null == t
          ? _value.t
          : t // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$FrostParamsImpl implements _FrostParams {
  const _$FrostParamsImpl({required this.id, required this.n, required this.t});

  @override
  final int id;
  @override
  final int n;
  @override
  final int t;

  @override
  String toString() {
    return 'FrostParams(id: $id, n: $n, t: $t)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$FrostParamsImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.n, n) || other.n == n) &&
            (identical(other.t, t) || other.t == t));
  }

  @override
  int get hashCode => Object.hash(runtimeType, id, n, t);

  /// Create a copy of FrostParams
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$FrostParamsImplCopyWith<_$FrostParamsImpl> get copyWith =>
      __$$FrostParamsImplCopyWithImpl<_$FrostParamsImpl>(this, _$identity);
}

abstract class _FrostParams implements FrostParams {
  const factory _FrostParams(
      {required final int id,
      required final int n,
      required final int t}) = _$FrostParamsImpl;

  @override
  int get id;
  @override
  int get n;
  @override
  int get t;

  /// Create a copy of FrostParams
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$FrostParamsImplCopyWith<_$FrostParamsImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$Memo {
  int get id => throw _privateConstructorUsedError;
  int get idTx => throw _privateConstructorUsedError;
  int? get idNote => throw _privateConstructorUsedError;
  int get pool => throw _privateConstructorUsedError;
  int get height => throw _privateConstructorUsedError;
  int get vout => throw _privateConstructorUsedError;
  int get time => throw _privateConstructorUsedError;
  Uint8List get memoBytes => throw _privateConstructorUsedError;
  String? get memo => throw _privateConstructorUsedError;

  /// Create a copy of Memo
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $MemoCopyWith<Memo> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MemoCopyWith<$Res> {
  factory $MemoCopyWith(Memo value, $Res Function(Memo) then) =
      _$MemoCopyWithImpl<$Res, Memo>;
  @useResult
  $Res call(
      {int id,
      int idTx,
      int? idNote,
      int pool,
      int height,
      int vout,
      int time,
      Uint8List memoBytes,
      String? memo});
}

/// @nodoc
class _$MemoCopyWithImpl<$Res, $Val extends Memo>
    implements $MemoCopyWith<$Res> {
  _$MemoCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of Memo
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? idTx = null,
    Object? idNote = freezed,
    Object? pool = null,
    Object? height = null,
    Object? vout = null,
    Object? time = null,
    Object? memoBytes = null,
    Object? memo = freezed,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as int,
      idTx: null == idTx
          ? _value.idTx
          : idTx // ignore: cast_nullable_to_non_nullable
              as int,
      idNote: freezed == idNote
          ? _value.idNote
          : idNote // ignore: cast_nullable_to_non_nullable
              as int?,
      pool: null == pool
          ? _value.pool
          : pool // ignore: cast_nullable_to_non_nullable
              as int,
      height: null == height
          ? _value.height
          : height // ignore: cast_nullable_to_non_nullable
              as int,
      vout: null == vout
          ? _value.vout
          : vout // ignore: cast_nullable_to_non_nullable
              as int,
      time: null == time
          ? _value.time
          : time // ignore: cast_nullable_to_non_nullable
              as int,
      memoBytes: null == memoBytes
          ? _value.memoBytes
          : memoBytes // ignore: cast_nullable_to_non_nullable
              as Uint8List,
      memo: freezed == memo
          ? _value.memo
          : memo // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$MemoImplCopyWith<$Res> implements $MemoCopyWith<$Res> {
  factory _$$MemoImplCopyWith(
          _$MemoImpl value, $Res Function(_$MemoImpl) then) =
      __$$MemoImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {int id,
      int idTx,
      int? idNote,
      int pool,
      int height,
      int vout,
      int time,
      Uint8List memoBytes,
      String? memo});
}

/// @nodoc
class __$$MemoImplCopyWithImpl<$Res>
    extends _$MemoCopyWithImpl<$Res, _$MemoImpl>
    implements _$$MemoImplCopyWith<$Res> {
  __$$MemoImplCopyWithImpl(_$MemoImpl _value, $Res Function(_$MemoImpl) _then)
      : super(_value, _then);

  /// Create a copy of Memo
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? idTx = null,
    Object? idNote = freezed,
    Object? pool = null,
    Object? height = null,
    Object? vout = null,
    Object? time = null,
    Object? memoBytes = null,
    Object? memo = freezed,
  }) {
    return _then(_$MemoImpl(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as int,
      idTx: null == idTx
          ? _value.idTx
          : idTx // ignore: cast_nullable_to_non_nullable
              as int,
      idNote: freezed == idNote
          ? _value.idNote
          : idNote // ignore: cast_nullable_to_non_nullable
              as int?,
      pool: null == pool
          ? _value.pool
          : pool // ignore: cast_nullable_to_non_nullable
              as int,
      height: null == height
          ? _value.height
          : height // ignore: cast_nullable_to_non_nullable
              as int,
      vout: null == vout
          ? _value.vout
          : vout // ignore: cast_nullable_to_non_nullable
              as int,
      time: null == time
          ? _value.time
          : time // ignore: cast_nullable_to_non_nullable
              as int,
      memoBytes: null == memoBytes
          ? _value.memoBytes
          : memoBytes // ignore: cast_nullable_to_non_nullable
              as Uint8List,
      memo: freezed == memo
          ? _value.memo
          : memo // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc

class _$MemoImpl implements _Memo {
  const _$MemoImpl(
      {required this.id,
      required this.idTx,
      this.idNote,
      required this.pool,
      required this.height,
      required this.vout,
      required this.time,
      required this.memoBytes,
      this.memo});

  @override
  final int id;
  @override
  final int idTx;
  @override
  final int? idNote;
  @override
  final int pool;
  @override
  final int height;
  @override
  final int vout;
  @override
  final int time;
  @override
  final Uint8List memoBytes;
  @override
  final String? memo;

  @override
  String toString() {
    return 'Memo(id: $id, idTx: $idTx, idNote: $idNote, pool: $pool, height: $height, vout: $vout, time: $time, memoBytes: $memoBytes, memo: $memo)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$MemoImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.idTx, idTx) || other.idTx == idTx) &&
            (identical(other.idNote, idNote) || other.idNote == idNote) &&
            (identical(other.pool, pool) || other.pool == pool) &&
            (identical(other.height, height) || other.height == height) &&
            (identical(other.vout, vout) || other.vout == vout) &&
            (identical(other.time, time) || other.time == time) &&
            const DeepCollectionEquality().equals(other.memoBytes, memoBytes) &&
            (identical(other.memo, memo) || other.memo == memo));
  }

  @override
  int get hashCode => Object.hash(runtimeType, id, idTx, idNote, pool, height,
      vout, time, const DeepCollectionEquality().hash(memoBytes), memo);

  /// Create a copy of Memo
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$MemoImplCopyWith<_$MemoImpl> get copyWith =>
      __$$MemoImplCopyWithImpl<_$MemoImpl>(this, _$identity);
}

abstract class _Memo implements Memo {
  const factory _Memo(
      {required final int id,
      required final int idTx,
      final int? idNote,
      required final int pool,
      required final int height,
      required final int vout,
      required final int time,
      required final Uint8List memoBytes,
      final String? memo}) = _$MemoImpl;

  @override
  int get id;
  @override
  int get idTx;
  @override
  int? get idNote;
  @override
  int get pool;
  @override
  int get height;
  @override
  int get vout;
  @override
  int get time;
  @override
  Uint8List get memoBytes;
  @override
  String? get memo;

  /// Create a copy of Memo
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$MemoImplCopyWith<_$MemoImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$NewAccount {
  Uint8List? get icon => throw _privateConstructorUsedError;
  String get name => throw _privateConstructorUsedError;
  bool get restore => throw _privateConstructorUsedError;
  String get key => throw _privateConstructorUsedError;
  String? get passphrase => throw _privateConstructorUsedError;
  Uint8List? get fingerprint => throw _privateConstructorUsedError;
  int get aindex => throw _privateConstructorUsedError;
  int? get birth => throw _privateConstructorUsedError;
  String get folder => throw _privateConstructorUsedError;
  int? get pools => throw _privateConstructorUsedError;
  bool get useInternal => throw _privateConstructorUsedError;
  bool get internal => throw _privateConstructorUsedError;

  /// Create a copy of NewAccount
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $NewAccountCopyWith<NewAccount> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $NewAccountCopyWith<$Res> {
  factory $NewAccountCopyWith(
          NewAccount value, $Res Function(NewAccount) then) =
      _$NewAccountCopyWithImpl<$Res, NewAccount>;
  @useResult
  $Res call(
      {Uint8List? icon,
      String name,
      bool restore,
      String key,
      String? passphrase,
      Uint8List? fingerprint,
      int aindex,
      int? birth,
      String folder,
      int? pools,
      bool useInternal,
      bool internal});
}

/// @nodoc
class _$NewAccountCopyWithImpl<$Res, $Val extends NewAccount>
    implements $NewAccountCopyWith<$Res> {
  _$NewAccountCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of NewAccount
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? icon = freezed,
    Object? name = null,
    Object? restore = null,
    Object? key = null,
    Object? passphrase = freezed,
    Object? fingerprint = freezed,
    Object? aindex = null,
    Object? birth = freezed,
    Object? folder = null,
    Object? pools = freezed,
    Object? useInternal = null,
    Object? internal = null,
  }) {
    return _then(_value.copyWith(
      icon: freezed == icon
          ? _value.icon
          : icon // ignore: cast_nullable_to_non_nullable
              as Uint8List?,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      restore: null == restore
          ? _value.restore
          : restore // ignore: cast_nullable_to_non_nullable
              as bool,
      key: null == key
          ? _value.key
          : key // ignore: cast_nullable_to_non_nullable
              as String,
      passphrase: freezed == passphrase
          ? _value.passphrase
          : passphrase // ignore: cast_nullable_to_non_nullable
              as String?,
      fingerprint: freezed == fingerprint
          ? _value.fingerprint
          : fingerprint // ignore: cast_nullable_to_non_nullable
              as Uint8List?,
      aindex: null == aindex
          ? _value.aindex
          : aindex // ignore: cast_nullable_to_non_nullable
              as int,
      birth: freezed == birth
          ? _value.birth
          : birth // ignore: cast_nullable_to_non_nullable
              as int?,
      folder: null == folder
          ? _value.folder
          : folder // ignore: cast_nullable_to_non_nullable
              as String,
      pools: freezed == pools
          ? _value.pools
          : pools // ignore: cast_nullable_to_non_nullable
              as int?,
      useInternal: null == useInternal
          ? _value.useInternal
          : useInternal // ignore: cast_nullable_to_non_nullable
              as bool,
      internal: null == internal
          ? _value.internal
          : internal // ignore: cast_nullable_to_non_nullable
              as bool,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$NewAccountImplCopyWith<$Res>
    implements $NewAccountCopyWith<$Res> {
  factory _$$NewAccountImplCopyWith(
          _$NewAccountImpl value, $Res Function(_$NewAccountImpl) then) =
      __$$NewAccountImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {Uint8List? icon,
      String name,
      bool restore,
      String key,
      String? passphrase,
      Uint8List? fingerprint,
      int aindex,
      int? birth,
      String folder,
      int? pools,
      bool useInternal,
      bool internal});
}

/// @nodoc
class __$$NewAccountImplCopyWithImpl<$Res>
    extends _$NewAccountCopyWithImpl<$Res, _$NewAccountImpl>
    implements _$$NewAccountImplCopyWith<$Res> {
  __$$NewAccountImplCopyWithImpl(
      _$NewAccountImpl _value, $Res Function(_$NewAccountImpl) _then)
      : super(_value, _then);

  /// Create a copy of NewAccount
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? icon = freezed,
    Object? name = null,
    Object? restore = null,
    Object? key = null,
    Object? passphrase = freezed,
    Object? fingerprint = freezed,
    Object? aindex = null,
    Object? birth = freezed,
    Object? folder = null,
    Object? pools = freezed,
    Object? useInternal = null,
    Object? internal = null,
  }) {
    return _then(_$NewAccountImpl(
      icon: freezed == icon
          ? _value.icon
          : icon // ignore: cast_nullable_to_non_nullable
              as Uint8List?,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      restore: null == restore
          ? _value.restore
          : restore // ignore: cast_nullable_to_non_nullable
              as bool,
      key: null == key
          ? _value.key
          : key // ignore: cast_nullable_to_non_nullable
              as String,
      passphrase: freezed == passphrase
          ? _value.passphrase
          : passphrase // ignore: cast_nullable_to_non_nullable
              as String?,
      fingerprint: freezed == fingerprint
          ? _value.fingerprint
          : fingerprint // ignore: cast_nullable_to_non_nullable
              as Uint8List?,
      aindex: null == aindex
          ? _value.aindex
          : aindex // ignore: cast_nullable_to_non_nullable
              as int,
      birth: freezed == birth
          ? _value.birth
          : birth // ignore: cast_nullable_to_non_nullable
              as int?,
      folder: null == folder
          ? _value.folder
          : folder // ignore: cast_nullable_to_non_nullable
              as String,
      pools: freezed == pools
          ? _value.pools
          : pools // ignore: cast_nullable_to_non_nullable
              as int?,
      useInternal: null == useInternal
          ? _value.useInternal
          : useInternal // ignore: cast_nullable_to_non_nullable
              as bool,
      internal: null == internal
          ? _value.internal
          : internal // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc

class _$NewAccountImpl implements _NewAccount {
  const _$NewAccountImpl(
      {this.icon,
      required this.name,
      required this.restore,
      required this.key,
      this.passphrase,
      this.fingerprint,
      required this.aindex,
      this.birth,
      required this.folder,
      this.pools,
      required this.useInternal,
      required this.internal});

  @override
  final Uint8List? icon;
  @override
  final String name;
  @override
  final bool restore;
  @override
  final String key;
  @override
  final String? passphrase;
  @override
  final Uint8List? fingerprint;
  @override
  final int aindex;
  @override
  final int? birth;
  @override
  final String folder;
  @override
  final int? pools;
  @override
  final bool useInternal;
  @override
  final bool internal;

  @override
  String toString() {
    return 'NewAccount(icon: $icon, name: $name, restore: $restore, key: $key, passphrase: $passphrase, fingerprint: $fingerprint, aindex: $aindex, birth: $birth, folder: $folder, pools: $pools, useInternal: $useInternal, internal: $internal)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$NewAccountImpl &&
            const DeepCollectionEquality().equals(other.icon, icon) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.restore, restore) || other.restore == restore) &&
            (identical(other.key, key) || other.key == key) &&
            (identical(other.passphrase, passphrase) ||
                other.passphrase == passphrase) &&
            const DeepCollectionEquality()
                .equals(other.fingerprint, fingerprint) &&
            (identical(other.aindex, aindex) || other.aindex == aindex) &&
            (identical(other.birth, birth) || other.birth == birth) &&
            (identical(other.folder, folder) || other.folder == folder) &&
            (identical(other.pools, pools) || other.pools == pools) &&
            (identical(other.useInternal, useInternal) ||
                other.useInternal == useInternal) &&
            (identical(other.internal, internal) ||
                other.internal == internal));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(icon),
      name,
      restore,
      key,
      passphrase,
      const DeepCollectionEquality().hash(fingerprint),
      aindex,
      birth,
      folder,
      pools,
      useInternal,
      internal);

  /// Create a copy of NewAccount
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$NewAccountImplCopyWith<_$NewAccountImpl> get copyWith =>
      __$$NewAccountImplCopyWithImpl<_$NewAccountImpl>(this, _$identity);
}

abstract class _NewAccount implements NewAccount {
  const factory _NewAccount(
      {final Uint8List? icon,
      required final String name,
      required final bool restore,
      required final String key,
      final String? passphrase,
      final Uint8List? fingerprint,
      required final int aindex,
      final int? birth,
      required final String folder,
      final int? pools,
      required final bool useInternal,
      required final bool internal}) = _$NewAccountImpl;

  @override
  Uint8List? get icon;
  @override
  String get name;
  @override
  bool get restore;
  @override
  String get key;
  @override
  String? get passphrase;
  @override
  Uint8List? get fingerprint;
  @override
  int get aindex;
  @override
  int? get birth;
  @override
  String get folder;
  @override
  int? get pools;
  @override
  bool get useInternal;
  @override
  bool get internal;

  /// Create a copy of NewAccount
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$NewAccountImplCopyWith<_$NewAccountImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$Seed {
  String get mnemonic => throw _privateConstructorUsedError;
  String get phrase => throw _privateConstructorUsedError;
  int get aindex => throw _privateConstructorUsedError;

  /// Create a copy of Seed
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $SeedCopyWith<Seed> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SeedCopyWith<$Res> {
  factory $SeedCopyWith(Seed value, $Res Function(Seed) then) =
      _$SeedCopyWithImpl<$Res, Seed>;
  @useResult
  $Res call({String mnemonic, String phrase, int aindex});
}

/// @nodoc
class _$SeedCopyWithImpl<$Res, $Val extends Seed>
    implements $SeedCopyWith<$Res> {
  _$SeedCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of Seed
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? mnemonic = null,
    Object? phrase = null,
    Object? aindex = null,
  }) {
    return _then(_value.copyWith(
      mnemonic: null == mnemonic
          ? _value.mnemonic
          : mnemonic // ignore: cast_nullable_to_non_nullable
              as String,
      phrase: null == phrase
          ? _value.phrase
          : phrase // ignore: cast_nullable_to_non_nullable
              as String,
      aindex: null == aindex
          ? _value.aindex
          : aindex // ignore: cast_nullable_to_non_nullable
              as int,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$SeedImplCopyWith<$Res> implements $SeedCopyWith<$Res> {
  factory _$$SeedImplCopyWith(
          _$SeedImpl value, $Res Function(_$SeedImpl) then) =
      __$$SeedImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String mnemonic, String phrase, int aindex});
}

/// @nodoc
class __$$SeedImplCopyWithImpl<$Res>
    extends _$SeedCopyWithImpl<$Res, _$SeedImpl>
    implements _$$SeedImplCopyWith<$Res> {
  __$$SeedImplCopyWithImpl(_$SeedImpl _value, $Res Function(_$SeedImpl) _then)
      : super(_value, _then);

  /// Create a copy of Seed
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? mnemonic = null,
    Object? phrase = null,
    Object? aindex = null,
  }) {
    return _then(_$SeedImpl(
      mnemonic: null == mnemonic
          ? _value.mnemonic
          : mnemonic // ignore: cast_nullable_to_non_nullable
              as String,
      phrase: null == phrase
          ? _value.phrase
          : phrase // ignore: cast_nullable_to_non_nullable
              as String,
      aindex: null == aindex
          ? _value.aindex
          : aindex // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$SeedImpl implements _Seed {
  const _$SeedImpl(
      {required this.mnemonic, required this.phrase, required this.aindex});

  @override
  final String mnemonic;
  @override
  final String phrase;
  @override
  final int aindex;

  @override
  String toString() {
    return 'Seed(mnemonic: $mnemonic, phrase: $phrase, aindex: $aindex)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SeedImpl &&
            (identical(other.mnemonic, mnemonic) ||
                other.mnemonic == mnemonic) &&
            (identical(other.phrase, phrase) || other.phrase == phrase) &&
            (identical(other.aindex, aindex) || other.aindex == aindex));
  }

  @override
  int get hashCode => Object.hash(runtimeType, mnemonic, phrase, aindex);

  /// Create a copy of Seed
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$SeedImplCopyWith<_$SeedImpl> get copyWith =>
      __$$SeedImplCopyWithImpl<_$SeedImpl>(this, _$identity);
}

abstract class _Seed implements Seed {
  const factory _Seed(
      {required final String mnemonic,
      required final String phrase,
      required final int aindex}) = _$SeedImpl;

  @override
  String get mnemonic;
  @override
  String get phrase;
  @override
  int get aindex;

  /// Create a copy of Seed
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$SeedImplCopyWith<_$SeedImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$Tx {
  int get id => throw _privateConstructorUsedError;
  Uint8List get txid => throw _privateConstructorUsedError;
  int get height => throw _privateConstructorUsedError;
  int get time => throw _privateConstructorUsedError;
  int get value => throw _privateConstructorUsedError;
  int? get tpe => throw _privateConstructorUsedError;

  /// Create a copy of Tx
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $TxCopyWith<Tx> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $TxCopyWith<$Res> {
  factory $TxCopyWith(Tx value, $Res Function(Tx) then) =
      _$TxCopyWithImpl<$Res, Tx>;
  @useResult
  $Res call(
      {int id, Uint8List txid, int height, int time, int value, int? tpe});
}

/// @nodoc
class _$TxCopyWithImpl<$Res, $Val extends Tx> implements $TxCopyWith<$Res> {
  _$TxCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of Tx
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? txid = null,
    Object? height = null,
    Object? time = null,
    Object? value = null,
    Object? tpe = freezed,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as int,
      txid: null == txid
          ? _value.txid
          : txid // ignore: cast_nullable_to_non_nullable
              as Uint8List,
      height: null == height
          ? _value.height
          : height // ignore: cast_nullable_to_non_nullable
              as int,
      time: null == time
          ? _value.time
          : time // ignore: cast_nullable_to_non_nullable
              as int,
      value: null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as int,
      tpe: freezed == tpe
          ? _value.tpe
          : tpe // ignore: cast_nullable_to_non_nullable
              as int?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$TxImplCopyWith<$Res> implements $TxCopyWith<$Res> {
  factory _$$TxImplCopyWith(_$TxImpl value, $Res Function(_$TxImpl) then) =
      __$$TxImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {int id, Uint8List txid, int height, int time, int value, int? tpe});
}

/// @nodoc
class __$$TxImplCopyWithImpl<$Res> extends _$TxCopyWithImpl<$Res, _$TxImpl>
    implements _$$TxImplCopyWith<$Res> {
  __$$TxImplCopyWithImpl(_$TxImpl _value, $Res Function(_$TxImpl) _then)
      : super(_value, _then);

  /// Create a copy of Tx
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? txid = null,
    Object? height = null,
    Object? time = null,
    Object? value = null,
    Object? tpe = freezed,
  }) {
    return _then(_$TxImpl(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as int,
      txid: null == txid
          ? _value.txid
          : txid // ignore: cast_nullable_to_non_nullable
              as Uint8List,
      height: null == height
          ? _value.height
          : height // ignore: cast_nullable_to_non_nullable
              as int,
      time: null == time
          ? _value.time
          : time // ignore: cast_nullable_to_non_nullable
              as int,
      value: null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as int,
      tpe: freezed == tpe
          ? _value.tpe
          : tpe // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }
}

/// @nodoc

class _$TxImpl implements _Tx {
  const _$TxImpl(
      {required this.id,
      required this.txid,
      required this.height,
      required this.time,
      required this.value,
      this.tpe});

  @override
  final int id;
  @override
  final Uint8List txid;
  @override
  final int height;
  @override
  final int time;
  @override
  final int value;
  @override
  final int? tpe;

  @override
  String toString() {
    return 'Tx(id: $id, txid: $txid, height: $height, time: $time, value: $value, tpe: $tpe)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$TxImpl &&
            (identical(other.id, id) || other.id == id) &&
            const DeepCollectionEquality().equals(other.txid, txid) &&
            (identical(other.height, height) || other.height == height) &&
            (identical(other.time, time) || other.time == time) &&
            (identical(other.value, value) || other.value == value) &&
            (identical(other.tpe, tpe) || other.tpe == tpe));
  }

  @override
  int get hashCode => Object.hash(runtimeType, id,
      const DeepCollectionEquality().hash(txid), height, time, value, tpe);

  /// Create a copy of Tx
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$TxImplCopyWith<_$TxImpl> get copyWith =>
      __$$TxImplCopyWithImpl<_$TxImpl>(this, _$identity);
}

abstract class _Tx implements Tx {
  const factory _Tx(
      {required final int id,
      required final Uint8List txid,
      required final int height,
      required final int time,
      required final int value,
      final int? tpe}) = _$TxImpl;

  @override
  int get id;
  @override
  Uint8List get txid;
  @override
  int get height;
  @override
  int get time;
  @override
  int get value;
  @override
  int? get tpe;

  /// Create a copy of Tx
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$TxImplCopyWith<_$TxImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
