// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../account.dart';
import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'package:freezed_annotation/freezed_annotation.dart' hide protected;
part 'account.freezed.dart';

Future<int> getAccountPools({required int account}) =>
    RustLib.instance.api.crateApiAccountGetAccountPools(account: account);

Future<String> getAccountUfvk({required int account, required int pools}) =>
    RustLib.instance.api
        .crateApiAccountGetAccountUfvk(account: account, pools: pools);

Future<Seed?> getAccountSeed({required int account}) =>
    RustLib.instance.api.crateApiAccountGetAccountSeed(account: account);

Future<String?> getAccountFingerprint({required int account}) =>
    RustLib.instance.api.crateApiAccountGetAccountFingerprint(account: account);

String uaFromUfvk({required String ufvk, int? di}) =>
    RustLib.instance.api.crateApiAccountUaFromUfvk(ufvk: ufvk, di: di);

Receivers receiversFromUa({required String ua}) =>
    RustLib.instance.api.crateApiAccountReceiversFromUa(ua: ua);

Future<List<Account>> listAccounts() =>
    RustLib.instance.api.crateApiAccountListAccounts();

Future<void> updateAccount({required AccountUpdate update}) =>
    RustLib.instance.api.crateApiAccountUpdateAccount(update: update);

Future<void> deleteAccount({required int account}) =>
    RustLib.instance.api.crateApiAccountDeleteAccount(account: account);

Future<void> reorderAccount(
        {required int oldPosition, required int newPosition}) =>
    RustLib.instance.api.crateApiAccountReorderAccount(
        oldPosition: oldPosition, newPosition: newPosition);

Future<void> setAccount({required int account}) =>
    RustLib.instance.api.crateApiAccountSetAccount(account: account);

Future<int> newAccount({required NewAccount na}) =>
    RustLib.instance.api.crateApiAccountNewAccount(na: na);

Future<int> generateNextDindex() =>
    RustLib.instance.api.crateApiAccountGenerateNextDindex();

Future<String?> generateNextChangeAddress() =>
    RustLib.instance.api.crateApiAccountGenerateNextChangeAddress();

Future<void> resetSync({required int id}) =>
    RustLib.instance.api.crateApiAccountResetSync(id: id);

Future<void> removeAccount({required int accountId}) =>
    RustLib.instance.api.crateApiAccountRemoveAccount(accountId: accountId);

Future<List<Tx>> listTxHistory() =>
    RustLib.instance.api.crateApiAccountListTxHistory();

Future<List<Memo>> listMemos() =>
    RustLib.instance.api.crateApiAccountListMemos();

Future<Addresses> getAddresses({required int uaPools}) =>
    RustLib.instance.api.crateApiAccountGetAddresses(uaPools: uaPools);

Future<TxAccount> getTxDetails({required int idTx}) =>
    RustLib.instance.api.crateApiAccountGetTxDetails(idTx: idTx);

Future<List<TxNote>> listNotes() =>
    RustLib.instance.api.crateApiAccountListNotes();

Future<void> lockNote({required int id, required bool locked}) =>
    RustLib.instance.api.crateApiAccountLockNote(id: id, locked: locked);

Future<List<TAddressTxCount>> fetchTransparentAddressTxCount() =>
    RustLib.instance.api.crateApiAccountFetchTransparentAddressTxCount();

Future<int> transparentSweep({required int endHeight, required int gapLimit}) =>
    RustLib.instance.api.crateApiAccountTransparentSweep(
        endHeight: endHeight, gapLimit: gapLimit);

Future<Uint8List> exportAccount(
        {required int id, required String passphrase}) =>
    RustLib.instance.api
        .crateApiAccountExportAccount(id: id, passphrase: passphrase);

Future<void> importAccount(
        {required String passphrase, required List<int> data}) =>
    RustLib.instance.api
        .crateApiAccountImportAccount(passphrase: passphrase, data: data);

Future<void> printKeys({required int id}) =>
    RustLib.instance.api.crateApiAccountPrintKeys(id: id);

Future<FrostParams?> getAccountFrostParams() =>
    RustLib.instance.api.crateApiAccountGetAccountFrostParams();

Future<List<Folder>> listFolders() =>
    RustLib.instance.api.crateApiAccountListFolders();

Future<Folder> createNewFolder({required String name}) =>
    RustLib.instance.api.crateApiAccountCreateNewFolder(name: name);

Future<void> renameFolder({required int id, required String name}) =>
    RustLib.instance.api.crateApiAccountRenameFolder(id: id, name: name);

Future<void> deleteFolders({required List<int> ids}) =>
    RustLib.instance.api.crateApiAccountDeleteFolders(ids: ids);

Future<List<Category>> listCategories() =>
    RustLib.instance.api.crateApiAccountListCategories();

Future<int> createNewCategory({required Category category}) =>
    RustLib.instance.api.crateApiAccountCreateNewCategory(category: category);

Future<void> renameCategory({required Category category}) =>
    RustLib.instance.api.crateApiAccountRenameCategory(category: category);

Future<void> deleteCategories({required List<int> ids}) =>
    RustLib.instance.api.crateApiAccountDeleteCategories(ids: ids);

Future<String> getExportedData({required int type}) =>
    RustLib.instance.api.crateApiAccountGetExportedData(type: type);

Future<void> lockRecentNotes({required int height, required int threshold}) =>
    RustLib.instance.api
        .crateApiAccountLockRecentNotes(height: height, threshold: threshold);

Future<void> unlockAllNotes() =>
    RustLib.instance.api.crateApiAccountUnlockAllNotes();

Future<BigInt> maxSpendable() =>
    RustLib.instance.api.crateApiAccountMaxSpendable();

@freezed
sealed class Account with _$Account {
  const factory Account({
    required int coin,
    required int id,
    required String name,
    String? seed,
    required int aindex,
    Uint8List? icon,
    required int birth,
    required Folder folder,
    required int position,
    required bool hidden,
    required bool saved,
    required bool enabled,
    required bool internal,
    required int height,
    required int time,
    required BigInt balance,
  }) = _Account;
}

@freezed
sealed class AccountUpdate with _$AccountUpdate {
  const factory AccountUpdate({
    required int coin,
    required int id,
    String? name,
    Uint8List? icon,
    int? birth,
    required int folder,
    bool? hidden,
    bool? enabled,
  }) = _AccountUpdate;
}

class Addresses {
  final String? taddr;
  final String? saddr;
  final String? oaddr;
  final String? ua;

  const Addresses({
    this.taddr,
    this.saddr,
    this.oaddr,
    this.ua,
  });

  @override
  int get hashCode =>
      taddr.hashCode ^ saddr.hashCode ^ oaddr.hashCode ^ ua.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Addresses &&
          runtimeType == other.runtimeType &&
          taddr == other.taddr &&
          saddr == other.saddr &&
          oaddr == other.oaddr &&
          ua == other.ua;
}

@freezed
sealed class Category with _$Category {
  const factory Category({
    required int id,
    required String name,
    required bool isIncome,
  }) = _Category;
}

@freezed
sealed class Folder with _$Folder {
  const factory Folder({
    required int id,
    required String name,
  }) = _Folder;
}

@freezed
sealed class FrostParams with _$FrostParams {
  const factory FrostParams({
    required int id,
    required int n,
    required int t,
  }) = _FrostParams;
}

@freezed
sealed class Memo with _$Memo {
  const factory Memo({
    required int id,
    required int idTx,
    int? idNote,
    required int pool,
    required int height,
    required int vout,
    required int time,
    required Uint8List memoBytes,
    String? memo,
  }) = _Memo;
}

@freezed
sealed class NewAccount with _$NewAccount {
  const factory NewAccount({
    Uint8List? icon,
    required String name,
    required bool restore,
    required String key,
    String? passphrase,
    Uint8List? fingerprint,
    required int aindex,
    int? birth,
    required String folder,
    int? pools,
    required bool useInternal,
    required bool internal,
  }) = _NewAccount;
}

class Receivers {
  final String? taddr;
  final String? saddr;
  final String? oaddr;

  const Receivers({
    this.taddr,
    this.saddr,
    this.oaddr,
  });

  static Future<Receivers> default_() =>
      RustLib.instance.api.crateApiAccountReceiversDefault();

  @override
  int get hashCode => taddr.hashCode ^ saddr.hashCode ^ oaddr.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Receivers &&
          runtimeType == other.runtimeType &&
          taddr == other.taddr &&
          saddr == other.saddr &&
          oaddr == other.oaddr;
}

@freezed
sealed class Seed with _$Seed {
  const factory Seed({
    required String mnemonic,
    required String phrase,
    required int aindex,
  }) = _Seed;
}

class TAddressTxCount {
  final String address;
  final int scope;
  final int dindex;
  final BigInt amount;
  final int txCount;
  final int time;

  const TAddressTxCount({
    required this.address,
    required this.scope,
    required this.dindex,
    required this.amount,
    required this.txCount,
    required this.time,
  });

  @override
  int get hashCode =>
      address.hashCode ^
      scope.hashCode ^
      dindex.hashCode ^
      amount.hashCode ^
      txCount.hashCode ^
      time.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is TAddressTxCount &&
          runtimeType == other.runtimeType &&
          address == other.address &&
          scope == other.scope &&
          dindex == other.dindex &&
          amount == other.amount &&
          txCount == other.txCount &&
          time == other.time;
}

@freezed
sealed class Tx with _$Tx {
  const factory Tx({
    required int id,
    required Uint8List txid,
    required int height,
    required int time,
    required PlatformInt64 value,
    int? tpe,
    String? category,
  }) = _Tx;
}
