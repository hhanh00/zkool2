// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.9.0.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'package:freezed_annotation/freezed_annotation.dart' hide protected;
part 'account.freezed.dart';

String newSeed({required String phrase}) =>
    RustLib.instance.api.crateApiAccountNewSeed(phrase: phrase);

int putAccountMetadata(
        {required String name,
        Uint8List? icon,
        required int birth,
        required int height}) =>
    RustLib.instance.api.crateApiAccountPutAccountMetadata(
        name: name, icon: icon, birth: birth, height: height);

int putAccountSeed(
        {required int id, required String phrase, required int aindex}) =>
    RustLib.instance.api
        .crateApiAccountPutAccountSeed(id: id, phrase: phrase, aindex: aindex);

int putAccountSaplingSecret({required int id, required String esk}) =>
    RustLib.instance.api
        .crateApiAccountPutAccountSaplingSecret(id: id, esk: esk);

int putAccountSaplingViewing({required int id, required String evk}) =>
    RustLib.instance.api
        .crateApiAccountPutAccountSaplingViewing(id: id, evk: evk);

int putAccountUnifiedViewing({required int id, required String uvk}) =>
    RustLib.instance.api
        .crateApiAccountPutAccountUnifiedViewing(id: id, uvk: uvk);

Future<int> putAccountTransparentSecret(
        {required int id, required String sk}) =>
    RustLib.instance.api
        .crateApiAccountPutAccountTransparentSecret(id: id, sk: sk);

String getAccountUfvk({required int id}) =>
    RustLib.instance.api.crateApiAccountGetAccountUfvk(id: id);

String uaFromUfvk({required String ufvk, int? di}) =>
    RustLib.instance.api.crateApiAccountUaFromUfvk(ufvk: ufvk, di: di);

Receivers receiversFromUa({required String ua}) =>
    RustLib.instance.api.crateApiAccountReceiversFromUa(ua: ua);

Future<List<Account>> listAccounts() =>
    RustLib.instance.api.crateApiAccountListAccounts();

void updateAccount({required AccountUpdate update}) =>
    RustLib.instance.api.crateApiAccountUpdateAccount(update: update);

void deleteAccount({required Account account}) =>
    RustLib.instance.api.crateApiAccountDeleteAccount(account: account);

Future<void> reorderAccount(
        {required int oldPosition, required int newPosition}) =>
    RustLib.instance.api.crateApiAccountReorderAccount(
        oldPosition: oldPosition, newPosition: newPosition);

void newAccount({required NewAccount newAccount}) =>
    RustLib.instance.api.crateApiAccountNewAccount(newAccount: newAccount);

@freezed
class Account with _$Account {
  const factory Account({
    required int coin,
    required int id,
    required String name,
    String? seed,
    required int aindex,
    Uint8List? icon,
    required int birth,
    required int height,
    required int position,
    required bool hidden,
    required bool saved,
    required bool enabled,
  }) = _Account;
}

@freezed
class AccountUpdate with _$AccountUpdate {
  const factory AccountUpdate({
    required int coin,
    required int id,
    String? name,
    Uint8List? icon,
    int? birth,
  }) = _AccountUpdate;
}

@freezed
class NewAccount with _$NewAccount {
  const factory NewAccount({
    required Uint8List icon,
    required String name,
    required bool restore,
    required String key,
    required int height,
  }) = _NewAccount;
}

class Receivers {
  final String? taddr;
  final String? saddr;
  final String? oaddr;

  const Receivers({
    this.taddr,
    this.saddr,
    this.oaddr,
  });

  static Future<Receivers> default_() =>
      RustLib.instance.api.crateApiAccountReceiversDefault();

  @override
  int get hashCode => taddr.hashCode ^ saddr.hashCode ^ oaddr.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Receivers &&
          runtimeType == other.runtimeType &&
          taddr == other.taddr &&
          saddr == other.saddr &&
          oaddr == other.oaddr;
}
