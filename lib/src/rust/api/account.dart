// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'coin.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'package:freezed_annotation/freezed_annotation.dart' hide protected;
part 'account.freezed.dart';

// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `fmt`, `fmt`, `fmt`, `fmt`, `fmt`

Future<int> getAccountPools({required int account, required Coin c}) =>
    RustLib.instance.api.crateApiAccountGetAccountPools(account: account, c: c);

Future<String> getAccountUfvk(
        {required int account, required int pools, required Coin c}) =>
    RustLib.instance.api
        .crateApiAccountGetAccountUfvk(account: account, pools: pools, c: c);

Future<Seed?> getAccountSeed({required int account, required Coin c}) =>
    RustLib.instance.api.crateApiAccountGetAccountSeed(account: account, c: c);

Future<String?> getAccountFingerprint(
        {required int account, required Coin c}) =>
    RustLib.instance.api
        .crateApiAccountGetAccountFingerprint(account: account, c: c);

String uaFromUfvk({required String ufvk, int? di, required Coin c}) =>
    RustLib.instance.api.crateApiAccountUaFromUfvk(ufvk: ufvk, di: di, c: c);

Receivers receiversFromUa({required String ua, required Coin c}) =>
    RustLib.instance.api.crateApiAccountReceiversFromUa(ua: ua, c: c);

Future<List<Account>> listAccounts({required Coin c}) =>
    RustLib.instance.api.crateApiAccountListAccounts(c: c);

Future<void> updateAccount({required AccountUpdate update, required Coin c}) =>
    RustLib.instance.api.crateApiAccountUpdateAccount(update: update, c: c);

Future<void> deleteAccount({required int account, required Coin c}) =>
    RustLib.instance.api.crateApiAccountDeleteAccount(account: account, c: c);

Future<void> reorderAccount(
        {required int oldPosition,
        required int newPosition,
        required Coin c}) =>
    RustLib.instance.api.crateApiAccountReorderAccount(
        oldPosition: oldPosition, newPosition: newPosition, c: c);

Future<int> newAccount({required NewAccount na, required Coin c}) =>
    RustLib.instance.api.crateApiAccountNewAccount(na: na, c: c);

Future<bool> hasTransparentPubKey({required Coin c}) =>
    RustLib.instance.api.crateApiAccountHasTransparentPubKey(c: c);

Future<int> generateNextDindex({required Coin c}) =>
    RustLib.instance.api.crateApiAccountGenerateNextDindex(c: c);

Future<String?> generateNextChangeAddress({required Coin c}) =>
    RustLib.instance.api.crateApiAccountGenerateNextChangeAddress(c: c);

Future<void> resetSync({required int id, required Coin c}) =>
    RustLib.instance.api.crateApiAccountResetSync(id: id, c: c);

Future<void> removeAccount({required int accountId, required Coin c}) =>
    RustLib.instance.api
        .crateApiAccountRemoveAccount(accountId: accountId, c: c);

Future<List<Tx>> listTxHistory({required Coin c}) =>
    RustLib.instance.api.crateApiAccountListTxHistory(c: c);

Future<List<Memo>> listMemos({required Coin c}) =>
    RustLib.instance.api.crateApiAccountListMemos(c: c);

Future<Addresses> getAddresses({required int uaPools, required Coin c}) =>
    RustLib.instance.api.crateApiAccountGetAddresses(uaPools: uaPools, c: c);

Future<TxAccount> getTxDetails({required int idTx, required Coin c}) =>
    RustLib.instance.api.crateApiAccountGetTxDetails(idTx: idTx, c: c);

Future<List<TxNote>> listNotes({required Coin c}) =>
    RustLib.instance.api.crateApiAccountListNotes(c: c);

Future<void> lockNote(
        {required int id, required bool locked, required Coin c}) =>
    RustLib.instance.api.crateApiAccountLockNote(id: id, locked: locked, c: c);

Future<List<TAddressTxCount>> fetchTransparentAddressTxCount(
        {required Coin c}) =>
    RustLib.instance.api.crateApiAccountFetchTransparentAddressTxCount(c: c);

Future<Uint8List> exportAccount(
        {required int id, required String passphrase, required Coin c}) =>
    RustLib.instance.api
        .crateApiAccountExportAccount(id: id, passphrase: passphrase, c: c);

Future<void> importAccount(
        {required String passphrase,
        required List<int> data,
        required Coin c}) =>
    RustLib.instance.api
        .crateApiAccountImportAccount(passphrase: passphrase, data: data, c: c);

Future<void> printKeys({required int id, required Coin c}) =>
    RustLib.instance.api.crateApiAccountPrintKeys(id: id, c: c);

Future<FrostParams?> getAccountFrostParams({required Coin c}) =>
    RustLib.instance.api.crateApiAccountGetAccountFrostParams(c: c);

Future<List<Folder>> listFolders({required Coin c}) =>
    RustLib.instance.api.crateApiAccountListFolders(c: c);

Future<Folder> createNewFolder({required String name, required Coin c}) =>
    RustLib.instance.api.crateApiAccountCreateNewFolder(name: name, c: c);

Future<void> renameFolder(
        {required int id, required String name, required Coin c}) =>
    RustLib.instance.api.crateApiAccountRenameFolder(id: id, name: name, c: c);

Future<void> deleteFolders({required List<int> ids, required Coin c}) =>
    RustLib.instance.api.crateApiAccountDeleteFolders(ids: ids, c: c);

Future<List<Category>> listCategories({required Coin c}) =>
    RustLib.instance.api.crateApiAccountListCategories(c: c);

Future<int> createNewCategory({required Category category, required Coin c}) =>
    RustLib.instance.api
        .crateApiAccountCreateNewCategory(category: category, c: c);

Future<void> renameCategory({required Category category, required Coin c}) =>
    RustLib.instance.api
        .crateApiAccountRenameCategory(category: category, c: c);

Future<void> deleteCategories({required List<int> ids, required Coin c}) =>
    RustLib.instance.api.crateApiAccountDeleteCategories(ids: ids, c: c);

Future<String> getExportedData({required int type, required Coin c}) =>
    RustLib.instance.api.crateApiAccountGetExportedData(type: type, c: c);

Future<void> lockRecentNotes(
        {required int height, required int threshold, required Coin c}) =>
    RustLib.instance.api.crateApiAccountLockRecentNotes(
        height: height, threshold: threshold, c: c);

Future<void> unlockAllNotes({required Coin c}) =>
    RustLib.instance.api.crateApiAccountUnlockAllNotes(c: c);

Future<BigInt> maxSpendable({required Coin c}) =>
    RustLib.instance.api.crateApiAccountMaxSpendable(c: c);

Future<String> showLedgerSaplingAddress({required Coin c}) =>
    RustLib.instance.api.crateApiAccountShowLedgerSaplingAddress(c: c);

Future<String> showLedgerTransparentAddress({required Coin c}) =>
    RustLib.instance.api.crateApiAccountShowLedgerTransparentAddress(c: c);

@freezed
sealed class Account with _$Account {
  const factory Account({
    required int coin,
    required int id,
    required String name,
    String? seed,
    String? passphrase,
    required int aindex,
    required int dindex,
    Uint8List? icon,
    required int birth,
    required Folder folder,
    required int position,
    required bool hidden,
    required bool saved,
    required bool enabled,
    required bool internal,
    required int hw,
    required int height,
    required int time,
    required BigInt balance,
  }) = _Account;
}

@freezed
sealed class AccountUpdate with _$AccountUpdate {
  const factory AccountUpdate({
    required int coin,
    required int id,
    String? name,
    Uint8List? icon,
    int? birth,
    required int folder,
    bool? hidden,
    bool? enabled,
  }) = _AccountUpdate;
}

class Addresses {
  final String? taddr;
  final String? saddr;
  final String? oaddr;
  final String? ua;

  const Addresses({
    this.taddr,
    this.saddr,
    this.oaddr,
    this.ua,
  });

  @override
  int get hashCode =>
      taddr.hashCode ^ saddr.hashCode ^ oaddr.hashCode ^ ua.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Addresses &&
          runtimeType == other.runtimeType &&
          taddr == other.taddr &&
          saddr == other.saddr &&
          oaddr == other.oaddr &&
          ua == other.ua;
}

@freezed
sealed class Category with _$Category {
  const factory Category({
    required int id,
    required String name,
    required bool isIncome,
  }) = _Category;
}

@freezed
sealed class Folder with _$Folder {
  const factory Folder({
    required int id,
    required String name,
  }) = _Folder;
}

@freezed
sealed class FrostParams with _$FrostParams {
  const factory FrostParams({
    required int id,
    required int n,
    required int t,
  }) = _FrostParams;
}

@freezed
sealed class Memo with _$Memo {
  const factory Memo({
    required int id,
    required int idTx,
    int? idNote,
    required int pool,
    required int height,
    required int vout,
    required int time,
    required Uint8List memoBytes,
    String? memo,
  }) = _Memo;
}

@freezed
sealed class NewAccount with _$NewAccount {
  const factory NewAccount({
    Uint8List? icon,
    required String name,
    required bool restore,
    required String key,
    String? passphrase,
    Uint8List? fingerprint,
    required int aindex,
    int? birth,
    required String folder,
    int? pools,
    required bool useInternal,
    required bool internal,
    required bool ledger,
  }) = _NewAccount;
}

class Receivers {
  final String? taddr;
  final String? saddr;
  final String? oaddr;

  const Receivers({
    this.taddr,
    this.saddr,
    this.oaddr,
  });

  static Future<Receivers> default_() =>
      RustLib.instance.api.crateApiAccountReceiversDefault();

  @override
  int get hashCode => taddr.hashCode ^ saddr.hashCode ^ oaddr.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Receivers &&
          runtimeType == other.runtimeType &&
          taddr == other.taddr &&
          saddr == other.saddr &&
          oaddr == other.oaddr;
}

@freezed
sealed class Seed with _$Seed {
  const factory Seed({
    required String mnemonic,
    required String phrase,
    required int aindex,
  }) = _Seed;
}

class TAddressTxCount {
  final String address;
  final int scope;
  final int dindex;
  final BigInt amount;
  final int txCount;
  final int time;

  const TAddressTxCount({
    required this.address,
    required this.scope,
    required this.dindex,
    required this.amount,
    required this.txCount,
    required this.time,
  });

  @override
  int get hashCode =>
      address.hashCode ^
      scope.hashCode ^
      dindex.hashCode ^
      amount.hashCode ^
      txCount.hashCode ^
      time.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is TAddressTxCount &&
          runtimeType == other.runtimeType &&
          address == other.address &&
          scope == other.scope &&
          dindex == other.dindex &&
          amount == other.amount &&
          txCount == other.txCount &&
          time == other.time;
}

@freezed
sealed class Tx with _$Tx {
  const factory Tx({
    required int id,
    required Uint8List txid,
    required int height,
    required int time,
    required PlatformInt64 value,
    int? tpe,
    String? category,
  }) = _Tx;
}

class TxAccount {
  final int id;
  final int account;
  final Uint8List txid;
  final int height;
  final int time;
  final double? price;
  final int? category;
  final List<TxNote> notes;
  final List<TxSpend> spends;
  final List<TxOutput> outputs;
  final List<TxMemo> memos;

  const TxAccount({
    required this.id,
    required this.account,
    required this.txid,
    required this.height,
    required this.time,
    this.price,
    this.category,
    required this.notes,
    required this.spends,
    required this.outputs,
    required this.memos,
  });

  static Future<TxAccount> default_() =>
      RustLib.instance.api.crateApiAccountTxAccountDefault();

  @override
  int get hashCode =>
      id.hashCode ^
      account.hashCode ^
      txid.hashCode ^
      height.hashCode ^
      time.hashCode ^
      price.hashCode ^
      category.hashCode ^
      notes.hashCode ^
      spends.hashCode ^
      outputs.hashCode ^
      memos.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is TxAccount &&
          runtimeType == other.runtimeType &&
          id == other.id &&
          account == other.account &&
          txid == other.txid &&
          height == other.height &&
          time == other.time &&
          price == other.price &&
          category == other.category &&
          notes == other.notes &&
          spends == other.spends &&
          outputs == other.outputs &&
          memos == other.memos;
}

class TxMemo {
  final int? note;
  final int? output;
  final int pool;
  final String? memo;

  const TxMemo({
    this.note,
    this.output,
    required this.pool,
    this.memo,
  });

  static Future<TxMemo> default_() =>
      RustLib.instance.api.crateApiAccountTxMemoDefault();

  @override
  int get hashCode =>
      note.hashCode ^ output.hashCode ^ pool.hashCode ^ memo.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is TxMemo &&
          runtimeType == other.runtimeType &&
          note == other.note &&
          output == other.output &&
          pool == other.pool &&
          memo == other.memo;
}

class TxNote {
  final int id;
  final int pool;
  final int height;
  final int tx;
  final int scope;
  final Uint8List? diversifier;
  final BigInt value;
  final bool locked;

  const TxNote({
    required this.id,
    required this.pool,
    required this.height,
    required this.tx,
    required this.scope,
    this.diversifier,
    required this.value,
    required this.locked,
  });

  static Future<TxNote> default_() =>
      RustLib.instance.api.crateApiAccountTxNoteDefault();

  @override
  int get hashCode =>
      id.hashCode ^
      pool.hashCode ^
      height.hashCode ^
      tx.hashCode ^
      scope.hashCode ^
      diversifier.hashCode ^
      value.hashCode ^
      locked.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is TxNote &&
          runtimeType == other.runtimeType &&
          id == other.id &&
          pool == other.pool &&
          height == other.height &&
          tx == other.tx &&
          scope == other.scope &&
          diversifier == other.diversifier &&
          value == other.value &&
          locked == other.locked;
}

class TxOutput {
  final int id;
  final int pool;
  final int height;
  final BigInt value;
  final String address;

  const TxOutput({
    required this.id,
    required this.pool,
    required this.height,
    required this.value,
    required this.address,
  });

  static Future<TxOutput> default_() =>
      RustLib.instance.api.crateApiAccountTxOutputDefault();

  @override
  int get hashCode =>
      id.hashCode ^
      pool.hashCode ^
      height.hashCode ^
      value.hashCode ^
      address.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is TxOutput &&
          runtimeType == other.runtimeType &&
          id == other.id &&
          pool == other.pool &&
          height == other.height &&
          value == other.value &&
          address == other.address;
}

class TxSpend {
  final int id;
  final int pool;
  final int height;
  final BigInt value;

  const TxSpend({
    required this.id,
    required this.pool,
    required this.height,
    required this.value,
  });

  static Future<TxSpend> default_() =>
      RustLib.instance.api.crateApiAccountTxSpendDefault();

  @override
  int get hashCode =>
      id.hashCode ^ pool.hashCode ^ height.hashCode ^ value.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is TxSpend &&
          runtimeType == other.runtimeType &&
          id == other.id &&
          pool == other.pool &&
          height == other.height &&
          value == other.value;
}
