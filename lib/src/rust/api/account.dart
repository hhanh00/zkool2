// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.9.0.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'package:freezed_annotation/freezed_annotation.dart' hide protected;
part 'account.freezed.dart';

String newSeed({required String phrase}) =>
    RustLib.instance.api.crateApiAccountNewSeed(phrase: phrase);

int putAccountMetadata(
        {required int coin,
        required String name,
        Uint8List? icon,
        required int birth,
        required int height}) =>
    RustLib.instance.api.crateApiAccountPutAccountMetadata(
        coin: coin, name: name, icon: icon, birth: birth, height: height);

int putAccountSeed(
        {required int coin,
        required int id,
        required String phrase,
        required int aindex}) =>
    RustLib.instance.api.crateApiAccountPutAccountSeed(
        coin: coin, id: id, phrase: phrase, aindex: aindex);

int putAccountSaplingSecret(
        {required int coin, required int id, required String esk}) =>
    RustLib.instance.api
        .crateApiAccountPutAccountSaplingSecret(coin: coin, id: id, esk: esk);

int putAccountSaplingViewing(
        {required int coin, required int id, required String evk}) =>
    RustLib.instance.api
        .crateApiAccountPutAccountSaplingViewing(coin: coin, id: id, evk: evk);

int putAccountUnifiedViewing(
        {required int coin, required int id, required String uvk}) =>
    RustLib.instance.api
        .crateApiAccountPutAccountUnifiedViewing(coin: coin, id: id, uvk: uvk);

Future<int> putAccountTransparentSecret(
        {required int coin, required int id, required String sk}) =>
    RustLib.instance.api
        .crateApiAccountPutAccountTransparentSecret(coin: coin, id: id, sk: sk);

String getAccountUfvk({required int coin, required int id}) =>
    RustLib.instance.api.crateApiAccountGetAccountUfvk(coin: coin, id: id);

String uaFromUfvk({required int coin, required String ufvk, int? di}) =>
    RustLib.instance.api
        .crateApiAccountUaFromUfvk(coin: coin, ufvk: ufvk, di: di);

Receivers receiversFromUa({required int coin, required String ua}) =>
    RustLib.instance.api.crateApiAccountReceiversFromUa(coin: coin, ua: ua);

Future<List<Account>> listAccounts({required int coin}) =>
    RustLib.instance.api.crateApiAccountListAccounts(coin: coin);

void updateAccount(
        {required int coin,
        required int id,
        String? name,
        Uint8List? icon,
        int? birth}) =>
    RustLib.instance.api.crateApiAccountUpdateAccount(
        coin: coin, id: id, name: name, icon: icon, birth: birth);

void setDbFilepath({required int coin, required String dbFilepath}) =>
    RustLib.instance.api
        .crateApiAccountSetDbFilepath(coin: coin, dbFilepath: dbFilepath);

@freezed
class Account with _$Account {
  const factory Account({
    required int coin,
    required int id,
    required String name,
    String? seed,
    required int aindex,
    Uint8List? icon,
    required int birth,
    required int height,
    required int position,
    required bool hidden,
    required bool saved,
    required bool enabled,
  }) = _Account;
}

class Receivers {
  final String? taddr;
  final String? saddr;
  final String? oaddr;

  const Receivers({
    this.taddr,
    this.saddr,
    this.oaddr,
  });

  static Future<Receivers> default_() =>
      RustLib.instance.api.crateApiAccountReceiversDefault();

  @override
  int get hashCode => taddr.hashCode ^ saddr.hashCode ^ oaddr.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Receivers &&
          runtimeType == other.runtimeType &&
          taddr == other.taddr &&
          saddr == other.saddr &&
          oaddr == other.oaddr;
}
